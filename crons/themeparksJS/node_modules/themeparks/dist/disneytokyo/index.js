"use strict";

// cookie library for reading geocookie for wait times

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var cookie = require("cookie");

var Moment = require("moment-timezone");

var Park = require("../park");
var GeoLocation = require("../geoLocation");

var s_parkID = Symbol();
var s_parkKind = Symbol();
var s_parkLocationMin = Symbol();
var s_parkLocationMax = Symbol();

/**
 * Implements the Tokyo Disneyland API framework.
 * @class
 * @extends Park
 */

var DisneyTokyoPark = function (_Park) {
    _inherits(DisneyTokyoPark, _Park);

    /**
     * Create new DisneyTokyoPark Object.
     * This object should not be called directly, but rather extended for each of the individual Tokyo Disneyland parks
     * @param {Object} options
     * @param {String} options.park_id Tokyo Disneyland API park ID
     */
    function DisneyTokyoPark() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, DisneyTokyoPark);

        options.name = options.name || "Tokyo Disneyland Park";

        // inherit from base class

        // assign park configurations
        var _this = _possibleConstructorReturn(this, (DisneyTokyoPark.__proto__ || Object.getPrototypeOf(DisneyTokyoPark)).call(this, options));

        if (!options.park_id) throw new Error("Missing park's API ID");
        _this[s_parkID] = options.park_id;
        if (!options.park_kind) throw new Error("Missing park's kind ID");
        _this[s_parkKind] = options.park_kind;
        // geoip range for generating valid cookie
        //  specify as two Location points
        if (!options.location_min || !(options.location_min instanceof GeoLocation)) throw new Error("Missing park's min location");
        if (!options.location_max || !(options.location_max instanceof GeoLocation)) throw new Error("Missing park's max location");
        _this[s_parkLocationMin] = options.location_min;
        _this[s_parkLocationMax] = options.location_max;
        return _this;
    }

    // override Fastpass Getter to declare support for Fastpass


    _createClass(DisneyTokyoPark, [{
        key: "FetchWaitTimes",


        /**
         * Refresh/Fetch new Wait Times for this Tokyo Disney Resort park
         * @returns {Promise}
         */
        value: function FetchWaitTimes() {
            var _this2 = this;

            return this.GetRideNames().then(function (rideData) {
                // fetch wait times HTML page
                return _this2.FetchWaitTimesURL().then(function (data) {
                    // parse HTML data
                    return _this2.ParseWaitTimesJSON(data).then(function (rideTimes) {
                        for (var rideIDX = 0; rideIDX < rideTimes.length; rideIDX++) {
                            var ride = rideTimes[rideIDX];

                            var rideObject = _this2.GetRideObject({
                                id: ride.ID,
                                name: rideData[ride.ID]
                            });

                            if (rideObject) {
                                rideObject.WaitTime = ride.WaitTime;
                                rideObject.FastPass = ride.FastPass;
                                if (ride.FastPassReturnTimeStart) {
                                    rideObject.FastPassReturnTimeStart = ride.FastPassReturnTimeStart;
                                }
                                if (ride.FastPassReturnTimeEnd) {
                                    rideObject.FastPassReturnTimeEnd = ride.FastPassReturnTimeEnd;
                                }
                            }
                        }

                        return Promise.resolve();
                    });
                });
            });
        }
    }, {
        key: "FetchWaitTimesURL",
        value: function FetchWaitTimesURL() {
            var _this3 = this;

            return this.GetAcccessToken().then(function (access_token) {
                return _this3.HTTP({
                    url: "https://www.tokyodisneyresort.jp/_/realtime/" + _this3[s_parkID] + "_attraction.json",
                    headers: {
                        "Cookie": "tdrloc=" + encodeURIComponent(access_token),
                        connection: "keep-alive"
                    },
                    retryDelay: 1000 * 10
                });
            });
        }
    }, {
        key: "ParseWaitTimesJSON",
        value: function ParseWaitTimesJSON(data) {
            var rides = [];

            for (var rideIDX = 0; rideIDX < data.length; rideIDX++) {
                var facilityStatus = Number(data[rideIDX].FacilityStatusCD);
                var operatingStatus = Number(data[rideIDX].OperatingStatusCD);

                // default ride status - current standby time
                var rideStatus = Number(data[rideIDX].StandbyTime);
                if (isNaN(rideStatus)) rideStatus = -1;

                // some rides don't show wait times, default to 0
                if (!data[rideIDX].UseStandbyTimeStyle) {
                    rideStatus = 0;
                }

                if (facilityStatus == 2 || operatingStatus == 2) {
                    // 1 means "closed" for the day
                    rideStatus = -1;
                } else if (facilityStatus == 3 || facilityStatus == 4 || operatingStatus == 3 || operatingStatus == 4) {
                    // status of 3 or 4 means "closed"
                    rideStatus = -1;
                } else if (operatingStatus == 5 || facilityStatus == 5) {
                    // status of 5 means "down"
                    rideStatus = -2;
                } else if (operatingStatus == 6 || facilityStatus == 6) {
                    // status 6 means "closed" unless you have a FastPass (it's right at the end of the day)
                    rideStatus = -1;
                }

                var ride = {
                    ID: Number(data[rideIDX].FacilityID),
                    WaitTime: rideStatus,
                    FastPass: data[rideIDX].FsStatus && data[rideIDX].FsStatusflg ? true : false // does ride support FastPass? (and does it have any left?)
                    // TODO: separate "has fastpass" and "any fastpass left?"
                };

                // process any found fastpass return times
                if (data[rideIDX].FsStatus && data[rideIDX].FsStatusflg && data[rideIDX].FsStatusStartTime !== null && data[rideIDX].FsStatusEndTime !== null) {
                    // we have start and end return times! convert to Moment objects and set
                    ride.FastPassReturnTimeStart = Moment.tz(data[rideIDX].FsStatusStartTime, "HH:mm", this.Timezone);
                    ride.FastPassReturnTimeEnd = Moment.tz(data[rideIDX].FsStatusEndTime, "HH:mm", this.Timezone);
                }

                rides.push(ride);
            }

            return Promise.resolve(rides);
        }
    }, {
        key: "FetchOpeningTimes",
        value: function FetchOpeningTimes() {
            return new Promise(function (resolve, reject) {
                // fetch 3 months of schedule data
                var today = Moment().tz(this.Timezone);
                this.FetchOpeningTimesForMonth(today.format("YYYYMM")).then(function () {
                    today.add(1, "month");
                    this.FetchOpeningTimesForMonth(today.format("YYYYMM")).then(function () {
                        today.add(1, "month");
                        this.FetchOpeningTimesForMonth(today.format("YYYYMM")).then(function () {
                            resolve();
                        }.bind(this), reject);
                    }.bind(this), reject);
                }.bind(this), reject);
            }.bind(this));
        }
    }, {
        key: "FetchOpeningTimesForMonth",
        value: function FetchOpeningTimesForMonth(month) {
            return new Promise(function (resolve, reject) {
                this.HTTP({
                    url: "http://www.tokyodisneyresort.jp/api/v1/wapi_monthlycalendars/detail/ym:" + month + "/",
                    headers: {
                        "Referer": "http://www.tokyodisneyresort.jp/en/attraction/lists/park:" + this[s_parkID],
                        "X-Requested-With": "XMLHttpRequest",
                        connection: "keep-alive"
                    },
                    forceJSON: true,
                    retryDelay: 1000 * 10
                }).then(function (body) {
                    if (!body || !body.entry) return reject("Failed to find data from TDR calendar");

                    for (var date in body.entry) {
                        if (body.entry[date][this[s_parkID]]) {
                            var scheduleDate = Moment(date, "YYYY/MM/DD");
                            this.Schedule.SetDate({
                                date: scheduleDate,
                                openingTime: Moment.tz(scheduleDate.format("YYYY-MM-DD") + " " + body.entry[date][this[s_parkID]].open_time_1, "YYYY-MM-DD HH:mm", this.Timezone),
                                closingTime: Moment.tz(scheduleDate.format("YYYY-MM-DD") + " " + body.entry[date][this[s_parkID]].close_time_1, "YYYY-MM-DD HH:mm", this.Timezone)
                            });
                        }
                    }

                    resolve();
                }.bind(this), reject);
            }.bind(this));
        }

        /**
         * Get the Geo-Locked access token for accessing Tokyo Disneyland wait times
         * @returns {Promise<String>} tdrloc cookie needed for accessing wait time pages
         */

    }, {
        key: "GetAcccessToken",
        value: function GetAcccessToken() {
            var cookieExpire;
            return this.Cache.Wrap("geocookie", function () {
                return new Promise(function (resolve, reject) {
                    var _this4 = this;

                    // generate a new geo cookie for accessing Tokyo ride data
                    var randomGeoLocation = GeoLocation.RandomBetween(this[s_parkLocationMin], this[s_parkLocationMax]);

                    this.HTTP({
                        method: "GET",
                        url: "https://www.tokyodisneyresort.jp/" + this[s_parkID] + "/realtime.html?nextUrl=" + this[s_parkID] + "attraction",
                        headers: {
                            connection: "keep-alive"
                        },
                        retryDelay: 1000 * 10
                    }).then(function (pageResp) {
                        // extract blockId and pageBlockId from page HTML
                        var pageRegex = /blockId=([0-9]+)&pageBlockId=([0-9]+)/;
                        var match = pageRegex.exec(pageResp);

                        if (!match) return reject("Unable to extract blockId and pageBlockId from Tokyo Disneyland page");

                        // request cookie for accessing wait times using a random location in the park
                        _this4.HTTP({
                            method: "POST",
                            url: "https://www.tokyodisneyresort.jp/view_interface.php?nextUrl=" + _this4[s_parkID] + "attraction&blockId=" + match[1] + "&pageBlockId=" + match[2],
                            data: {
                                lat: randomGeoLocation.LatitudeRaw,
                                lon: randomGeoLocation.LongitudeRaw
                            },
                            headers: {
                                connection: "keep-alive",
                                "Referer": "https://www.tokyodisneyresort.jp/" + _this4[s_parkID] + "/realtime",
                                "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
                                "X-Requested-With": "XMLHttpRequest",
                                "Origin": "https://www.tokyodisneyresort.jp"
                            },
                            // don't actually follow the redirect, we just want the cookie
                            follow_max: 0,
                            // we are actually only interested in the headers, so get the full response, not the body
                            returnFullResponse: true,
                            retryDelay: 1000 * 10
                        }).then(function (resp) {
                            if (resp.body && resp.body.result === false) {
                                return reject("Tokyo Disney Resort failed our location test");
                            }

                            if (resp && resp.headers && resp.headers["set-cookie"] && resp.headers["set-cookie"].length) {
                                // hunt for the tdrloc cookie
                                var GPSCookie,
                                    GPSExpiresIn = 60 * 30;
                                for (var i = 0, cookie_string; cookie_string = resp.headers["set-cookie"][i++];) {
                                    var cookie_data = cookie.parse(cookie_string);

                                    // search for any tdrloc cookie
                                    //  keep searching and keep the last set one
                                    //  their server usually sets it twice, first deleting it, then setting the correct one
                                    if (cookie_data && cookie_data.tdrloc) {
                                        GPSCookie = cookie_data.tdrloc;
                                        // parse cookie date to calculate expirey time in seconds
                                        GPSExpiresIn = Moment().diff(Moment(cookie_data.expires, "ddd, DD-MMM-YYYY HH:mm:ss z"), "seconds");

                                        // the cookie can actually be negative if the park is closed (weird, but OK)
                                        //  if this is so, keep the current one for 5 minutes and try again
                                        if (GPSExpiresIn < 0) {
                                            GPSExpiresIn = 60 * 5;
                                        }
                                    }
                                }

                                // did we find the cookie?
                                if (GPSCookie) {
                                    // set out-of-scope cookieExpire so we can tell the cache how long to keep this token
                                    //  take a little off to be safe (a minute)
                                    cookieExpire = GPSExpiresIn - 60;

                                    this.Log("Fetched new TDR geo-cookie: " + GPSCookie);

                                    // return the new cookie
                                    resolve(GPSCookie);
                                } else {
                                    return reject("Failed to find GPS Cookie from TDR website");
                                }
                            } else {
                                return reject("Missing GeoCookie from TDR response");
                            }
                        }.bind(_this4), reject);
                    });
                }.bind(this));
            }.bind(this), function () {
                return cookieExpire;
            }.bind(this));
        }

        /**
         * Fetch English ride names from the API
         * @returns {Promise<Object>} `rideID` to English names
         */

    }, {
        key: "GetRideNames",
        value: function GetRideNames() {
            return this.Cache.Wrap("ridenames", function () {
                return new Promise(function (resolve, reject) {
                    // fetch ride names
                    this.HTTP({
                        url: "http://www.tokyodisneyresort.jp/api/v1/wapi_attractions/lists/sort_type:1/locale:1/park_kind:" + this[s_parkKind] + "/",
                        forceJSON: true,
                        headers: {
                            "Referer": "http://www.tokyodisneyresort.jp/en/attraction/lists/park:" + this[s_parkID],
                            connection: "keep-alive"
                        },
                        retryDelay: 1000 * 10
                    }).then(function (body) {
                        if (!body || !body.entries || !body.entries.length) {
                            return reject("Failed to find entries in ride data response");
                        }

                        // populate data
                        var rideData = {};
                        for (var i = 0, ride; ride = body.entries[i++];) {
                            // use English if we can, fallback to yomi if we're missing an English name
                            rideData[ride.str_id] = ride.name || ride.name_yomi;
                        }

                        return resolve(rideData);
                    }.bind(this), reject);
                }.bind(this));
            }.bind(this), 86400);
        }
    }, {
        key: "FastPass",
        get: function get() {
            return true;
        }
    }]);

    return DisneyTokyoPark;
}(Park);

module.exports = DisneyTokyoPark;

if (!module.parent) {
    // test example wait times HTML page
    var S = new DisneyTokyoPark({
        latitude: 35.6277563214705,
        longitude: 139.8811161518097,
        park_id: "tds",
        park_kind: 2,
        location_min: new GeoLocation({
            latitude: 35.6277563214705,
            longitude: 139.8811161518097
        }),
        location_max: new GeoLocation({
            latitude: 35.62465172824325,
            longitude: 139.88948464393616
        })
    });

    // fetch new test HTML file
    /*S.FetchWaitTimesURL().then((HTML) => {
        require("fs").writeFileSync(__dirname + "/test.html", HTML);
    });*/

    // test parsing stored HTML file
    var HTML = require("fs").readFileSync(__dirname + "/test.html");
    S.ParseWaitTimesHTML(HTML).then(function (data) {
        S.Log(JSON.stringify(data, null, 2));
    });
}
//# sourceMappingURL=index.js.map