{"version":3,"sources":["../../lib/disneytokyo/index.js"],"names":["cookie","require","Moment","Park","GeoLocation","s_parkID","Symbol","s_parkKind","s_parkLocationMin","s_parkLocationMax","DisneyTokyoPark","options","name","park_id","Error","park_kind","location_min","location_max","GetRideNames","then","rideData","FetchWaitTimesURL","data","ParseWaitTimesJSON","rideTimes","rideIDX","length","ride","rideObject","GetRideObject","id","ID","WaitTime","FastPass","FastPassReturnTimeStart","FastPassReturnTimeEnd","Promise","resolve","GetAcccessToken","access_token","HTTP","url","headers","encodeURIComponent","connection","retryDelay","rides","facilityStatus","Number","FacilityStatusCD","operatingStatus","OperatingStatusCD","rideStatus","StandbyTime","isNaN","UseStandbyTimeStyle","FacilityID","FsStatus","FsStatusflg","FsStatusStartTime","FsStatusEndTime","tz","Timezone","push","reject","today","FetchOpeningTimesForMonth","format","add","bind","month","forceJSON","body","entry","date","scheduleDate","Schedule","SetDate","openingTime","open_time_1","closingTime","close_time_1","cookieExpire","Cache","Wrap","randomGeoLocation","RandomBetween","method","pageResp","pageRegex","match","exec","lat","LatitudeRaw","lon","LongitudeRaw","follow_max","returnFullResponse","resp","result","GPSCookie","GPSExpiresIn","i","cookie_string","cookie_data","parse","tdrloc","diff","expires","Log","entries","str_id","name_yomi","module","exports","parent","S","latitude","longitude","HTML","readFileSync","__dirname","ParseWaitTimesHTML","JSON","stringify"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\r\n\r\n// cookie library for reading geocookie for wait times\r\nvar cookie = require(\"cookie\");\r\n\r\nvar Moment = require(\"moment-timezone\");\r\n\r\nvar Park = require(\"../park\");\r\nvar GeoLocation = require(\"../geoLocation\");\r\n\r\nvar s_parkID = Symbol();\r\nvar s_parkKind = Symbol();\r\nvar s_parkLocationMin = Symbol();\r\nvar s_parkLocationMax = Symbol();\r\n\r\n/**\r\n * Implements the Tokyo Disneyland API framework.\r\n * @class\r\n * @extends Park\r\n */\r\nclass DisneyTokyoPark extends Park {\r\n    /**\r\n     * Create new DisneyTokyoPark Object.\r\n     * This object should not be called directly, but rather extended for each of the individual Tokyo Disneyland parks\r\n     * @param {Object} options\r\n     * @param {String} options.park_id Tokyo Disneyland API park ID\r\n     */\r\n    constructor(options = {}) {\r\n        options.name = options.name || \"Tokyo Disneyland Park\";\r\n\r\n        // inherit from base class\r\n        super(options);\r\n\r\n        // assign park configurations\r\n        if (!options.park_id) throw new Error(\"Missing park's API ID\");\r\n        this[s_parkID] = options.park_id;\r\n        if (!options.park_kind) throw new Error(\"Missing park's kind ID\");\r\n        this[s_parkKind] = options.park_kind;\r\n        // geoip range for generating valid cookie\r\n        //  specify as two Location points\r\n        if (!options.location_min || !(options.location_min instanceof GeoLocation)) throw new Error(\"Missing park's min location\");\r\n        if (!options.location_max || !(options.location_max instanceof GeoLocation)) throw new Error(\"Missing park's max location\");\r\n        this[s_parkLocationMin] = options.location_min;\r\n        this[s_parkLocationMax] = options.location_max;\r\n    }\r\n\r\n    // override Fastpass Getter to declare support for Fastpass\r\n    get FastPass() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Refresh/Fetch new Wait Times for this Tokyo Disney Resort park\r\n     * @returns {Promise}\r\n     */\r\n    FetchWaitTimes() {\r\n        return this.GetRideNames().then((rideData) => {\r\n            // fetch wait times HTML page\r\n            return this.FetchWaitTimesURL().then((data) => {\r\n                // parse HTML data\r\n                return this.ParseWaitTimesJSON(data).then((rideTimes) => {\r\n                    for (let rideIDX = 0; rideIDX < rideTimes.length; rideIDX++) {\r\n                        const ride = rideTimes[rideIDX];\r\n\r\n                        var rideObject = this.GetRideObject({\r\n                            id: ride.ID,\r\n                            name: rideData[ride.ID]\r\n                        });\r\n\r\n                        if (rideObject) {\r\n                            rideObject.WaitTime = ride.WaitTime;\r\n                            rideObject.FastPass = ride.FastPass;\r\n                            if (ride.FastPassReturnTimeStart) {\r\n                                rideObject.FastPassReturnTimeStart = ride.FastPassReturnTimeStart;\r\n                            }\r\n                            if (ride.FastPassReturnTimeEnd) {\r\n                                rideObject.FastPassReturnTimeEnd = ride.FastPassReturnTimeEnd;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return Promise.resolve();\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    FetchWaitTimesURL() {\r\n        return this.GetAcccessToken().then((access_token) => {\r\n            return this.HTTP({\r\n                url: `https://www.tokyodisneyresort.jp/_/realtime/${this[s_parkID]}_attraction.json`,\r\n                headers: {\r\n                    \"Cookie\": `tdrloc=${encodeURIComponent(access_token)}`,\r\n                    connection: \"keep-alive\",\r\n                },\r\n                retryDelay: 1000 * 10\r\n            });\r\n        });\r\n    }\r\n\r\n    ParseWaitTimesJSON(data) {\r\n        const rides = [];\r\n\r\n        for (let rideIDX = 0; rideIDX < data.length; rideIDX++) {\r\n            const facilityStatus = Number(data[rideIDX].FacilityStatusCD);\r\n            const operatingStatus = Number(data[rideIDX].OperatingStatusCD);\r\n\r\n            // default ride status - current standby time\r\n            let rideStatus = Number(data[rideIDX].StandbyTime);\r\n            if (isNaN(rideStatus)) rideStatus = -1;\r\n\r\n            // some rides don't show wait times, default to 0\r\n            if (!data[rideIDX].UseStandbyTimeStyle) {\r\n                rideStatus = 0;\r\n            }\r\n\r\n            if (facilityStatus == 2 || operatingStatus == 2) {\r\n                // 1 means \"closed\" for the day\r\n                rideStatus = -1;\r\n            } else if (facilityStatus == 3 || facilityStatus == 4 || operatingStatus == 3 || operatingStatus == 4) {\r\n                // status of 3 or 4 means \"closed\"\r\n                rideStatus = -1;\r\n            } else if (operatingStatus == 5 || facilityStatus == 5) {\r\n                // status of 5 means \"down\"\r\n                rideStatus = -2;\r\n            } else if (operatingStatus == 6 || facilityStatus == 6) {\r\n                // status 6 means \"closed\" unless you have a FastPass (it's right at the end of the day)\r\n                rideStatus = -1;\r\n            }\r\n\r\n            const ride = {\r\n                ID: Number(data[rideIDX].FacilityID),\r\n                WaitTime: rideStatus,\r\n                FastPass: (data[rideIDX].FsStatus && data[rideIDX].FsStatusflg) ? true : false // does ride support FastPass? (and does it have any left?)\r\n                // TODO: separate \"has fastpass\" and \"any fastpass left?\"\r\n            };\r\n\r\n            // process any found fastpass return times\r\n            if (data[rideIDX].FsStatus && data[rideIDX].FsStatusflg && data[rideIDX].FsStatusStartTime !== null && data[rideIDX].FsStatusEndTime !== null) {\r\n                // we have start and end return times! convert to Moment objects and set\r\n                ride.FastPassReturnTimeStart = Moment.tz(data[rideIDX].FsStatusStartTime, \"HH:mm\", this.Timezone);\r\n                ride.FastPassReturnTimeEnd = Moment.tz(data[rideIDX].FsStatusEndTime, \"HH:mm\", this.Timezone);\r\n            }\r\n\r\n            rides.push(ride);\r\n        }\r\n\r\n        return Promise.resolve(rides);\r\n    }\r\n\r\n    FetchOpeningTimes() {\r\n        return new Promise(function(resolve, reject) {\r\n            // fetch 3 months of schedule data\r\n            var today = Moment().tz(this.Timezone);\r\n            this.FetchOpeningTimesForMonth(today.format(\"YYYYMM\")).then(function() {\r\n                today.add(1, \"month\");\r\n                this.FetchOpeningTimesForMonth(today.format(\"YYYYMM\")).then(function() {\r\n                    today.add(1, \"month\");\r\n                    this.FetchOpeningTimesForMonth(today.format(\"YYYYMM\")).then(function() {\r\n                        resolve();\r\n                    }.bind(this), reject);\r\n                }.bind(this), reject);\r\n            }.bind(this), reject);\r\n        }.bind(this));\r\n    }\r\n\r\n    FetchOpeningTimesForMonth(month) {\r\n        return new Promise(function(resolve, reject) {\r\n            this.HTTP({\r\n                url: `http://www.tokyodisneyresort.jp/api/v1/wapi_monthlycalendars/detail/ym:${month}/`,\r\n                headers: {\r\n                    \"Referer\": `http://www.tokyodisneyresort.jp/en/attraction/lists/park:${this[s_parkID]}`,\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    connection: \"keep-alive\",\r\n                },\r\n                forceJSON: true,\r\n                retryDelay: 1000 * 10\r\n            }).then(function(body) {\r\n                if (!body || !body.entry) return reject(\"Failed to find data from TDR calendar\");\r\n\r\n                for (var date in body.entry) {\r\n                    if (body.entry[date][this[s_parkID]]) {\r\n                        var scheduleDate = Moment(date, \"YYYY/MM/DD\");\r\n                        this.Schedule.SetDate({\r\n                            date: scheduleDate,\r\n                            openingTime: Moment.tz(scheduleDate.format(\"YYYY-MM-DD\") + \" \" + body.entry[date][this[s_parkID]].open_time_1, \"YYYY-MM-DD HH:mm\", this.Timezone),\r\n                            closingTime: Moment.tz(scheduleDate.format(\"YYYY-MM-DD\") + \" \" + body.entry[date][this[s_parkID]].close_time_1, \"YYYY-MM-DD HH:mm\", this.Timezone),\r\n                        });\r\n                    }\r\n                }\r\n\r\n                resolve();\r\n            }.bind(this), reject);\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Get the Geo-Locked access token for accessing Tokyo Disneyland wait times\r\n     * @returns {Promise<String>} tdrloc cookie needed for accessing wait time pages\r\n     */\r\n    GetAcccessToken() {\r\n        var cookieExpire;\r\n        return this.Cache.Wrap(\"geocookie\", function() {\r\n            return new Promise(function(resolve, reject) {\r\n                // generate a new geo cookie for accessing Tokyo ride data\r\n                var randomGeoLocation = GeoLocation.RandomBetween(this[s_parkLocationMin], this[s_parkLocationMax]);\r\n\r\n                this.HTTP({\r\n                    method: \"GET\",\r\n                    url: `https://www.tokyodisneyresort.jp/${this[s_parkID]}/realtime.html?nextUrl=${this[s_parkID]}attraction`,\r\n                    headers: {\r\n                        connection: \"keep-alive\"\r\n                    },\r\n                    retryDelay: 1000 * 10\r\n                }).then((pageResp) => {\r\n                    // extract blockId and pageBlockId from page HTML\r\n                    const pageRegex = /blockId=([0-9]+)&pageBlockId=([0-9]+)/;\r\n                    const match = pageRegex.exec(pageResp);\r\n\r\n                    if (!match) return reject(\"Unable to extract blockId and pageBlockId from Tokyo Disneyland page\");\r\n\r\n                    // request cookie for accessing wait times using a random location in the park\r\n                    this.HTTP({\r\n                        method: \"POST\",\r\n                        url: `https://www.tokyodisneyresort.jp/view_interface.php?nextUrl=${this[s_parkID]}attraction&blockId=${match[1]}&pageBlockId=${match[2]}`,\r\n                        data: {\r\n                            lat: randomGeoLocation.LatitudeRaw,\r\n                            lon: randomGeoLocation.LongitudeRaw\r\n                        },\r\n                        headers: {\r\n                            connection: \"keep-alive\",\r\n                            \"Referer\": `https://www.tokyodisneyresort.jp/${this[s_parkID]}/realtime`,\r\n                            \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\",\r\n                            \"X-Requested-With\": \"XMLHttpRequest\",\r\n                            \"Origin\": \"https://www.tokyodisneyresort.jp\",\r\n                        },\r\n                        // don't actually follow the redirect, we just want the cookie\r\n                        follow_max: 0,\r\n                        // we are actually only interested in the headers, so get the full response, not the body\r\n                        returnFullResponse: true,\r\n                        retryDelay: 1000 * 10\r\n                    }).then(function(resp) {\r\n                        if (resp.body && resp.body.result === false) {\r\n                            return reject(\"Tokyo Disney Resort failed our location test\");\r\n                        }\r\n\r\n                        if (resp && resp.headers && resp.headers[\"set-cookie\"] && resp.headers[\"set-cookie\"].length) {\r\n                            // hunt for the tdrloc cookie\r\n                            var GPSCookie, GPSExpiresIn = 60 * 30;\r\n                            for (var i = 0, cookie_string; cookie_string = resp.headers[\"set-cookie\"][i++];) {\r\n                                var cookie_data = cookie.parse(cookie_string);\r\n\r\n                                // search for any tdrloc cookie\r\n                                //  keep searching and keep the last set one\r\n                                //  their server usually sets it twice, first deleting it, then setting the correct one\r\n                                if (cookie_data && cookie_data.tdrloc) {\r\n                                    GPSCookie = cookie_data.tdrloc;\r\n                                    // parse cookie date to calculate expirey time in seconds\r\n                                    GPSExpiresIn = Moment().diff(Moment(cookie_data.expires, \"ddd, DD-MMM-YYYY HH:mm:ss z\"), \"seconds\");\r\n\r\n                                    // the cookie can actually be negative if the park is closed (weird, but OK)\r\n                                    //  if this is so, keep the current one for 5 minutes and try again\r\n                                    if (GPSExpiresIn < 0) {\r\n                                        GPSExpiresIn = 60 * 5;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            // did we find the cookie?\r\n                            if (GPSCookie) {\r\n                                // set out-of-scope cookieExpire so we can tell the cache how long to keep this token\r\n                                //  take a little off to be safe (a minute)\r\n                                cookieExpire = GPSExpiresIn - 60;\r\n\r\n                                this.Log(`Fetched new TDR geo-cookie: ${GPSCookie}`);\r\n\r\n                                // return the new cookie\r\n                                resolve(GPSCookie);\r\n                            } else {\r\n                                return reject(\"Failed to find GPS Cookie from TDR website\");\r\n                            }\r\n                        } else {\r\n                            return reject(\"Missing GeoCookie from TDR response\");\r\n                        }\r\n                    }.bind(this), reject);\r\n                });\r\n            }.bind(this));\r\n        }.bind(this),\r\n        function() {\r\n            return cookieExpire;\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Fetch English ride names from the API\r\n     * @returns {Promise<Object>} `rideID` to English names\r\n     */\r\n    GetRideNames() {\r\n        return this.Cache.Wrap(\"ridenames\", function() {\r\n            return new Promise(function(resolve, reject) {\r\n                // fetch ride names\r\n                this.HTTP({\r\n                    url: `http://www.tokyodisneyresort.jp/api/v1/wapi_attractions/lists/sort_type:1/locale:1/park_kind:${this[s_parkKind]}/`,\r\n                    forceJSON: true,\r\n                    headers: {\r\n                        \"Referer\": `http://www.tokyodisneyresort.jp/en/attraction/lists/park:${this[s_parkID]}`,\r\n                        connection: \"keep-alive\",\r\n                    },\r\n                    retryDelay: 1000 * 10\r\n                }).then(function(body) {\r\n                    if (!body || !body.entries || !body.entries.length) {\r\n                        return reject(\"Failed to find entries in ride data response\");\r\n                    }\r\n\r\n                    // populate data\r\n                    var rideData = {};\r\n                    for (var i = 0, ride; ride = body.entries[i++];) {\r\n                        // use English if we can, fallback to yomi if we're missing an English name\r\n                        rideData[ride.str_id] = ride.name || ride.name_yomi;\r\n                    }\r\n\r\n                    return resolve(rideData);\r\n                }.bind(this), reject);\r\n            }.bind(this));\r\n        }.bind(this), 86400);\r\n    }\r\n}\r\n\r\nmodule.exports = DisneyTokyoPark;\r\n\r\nif (!module.parent) {\r\n    // test example wait times HTML page\r\n    var S = new DisneyTokyoPark({\r\n        latitude: 35.6277563214705,\r\n        longitude: 139.8811161518097,\r\n        park_id: \"tds\",\r\n        park_kind: 2,\r\n        location_min: new GeoLocation({\r\n            latitude: 35.6277563214705,\r\n            longitude: 139.8811161518097\r\n        }),\r\n        location_max: new GeoLocation({\r\n            latitude: 35.62465172824325,\r\n            longitude: 139.88948464393616\r\n        })\r\n    });\r\n\r\n    // fetch new test HTML file\r\n    /*S.FetchWaitTimesURL().then((HTML) => {\r\n        require(\"fs\").writeFileSync(__dirname + \"/test.html\", HTML);\r\n    });*/\r\n\r\n    // test parsing stored HTML file\r\n    var HTML = require(\"fs\").readFileSync(__dirname + \"/test.html\");\r\n    S.ParseWaitTimesHTML(HTML).then((data) => {\r\n        S.Log(JSON.stringify(data, null, 2));\r\n    });\r\n}"]}